import { NextResponse, type NextRequest } from 'next/server';
import { getAuth } from '@/lib/auth';
import { headers } from 'next/headers';
import { getStorage } from '@/lib/storage';
import crypto from 'node:crypto';
import { withApiLogging } from '@/lib/logging';
import { badRequest, unauthorized } from '@/lib/http';

const MAX_BYTES = 2 * 1024 * 1024; // 2MB
const ALLOWED_MIME = new Set(['image/png', 'image/jpeg', 'image/webp', 'image/gif']);
const EXT_BY_MIME: Record<string, string> = {
  'image/png': 'png',
  'image/jpeg': 'jpg',
  'image/webp': 'webp',
  'image/gif': 'gif',
};

function toSafePathSegment(value: string): string {
  // User IDs are generated by Better Auth, but never trust string content for filesystem keys.
  // Keep it stable, URL-safe, and free of path separators.
  const out = value.replace(/[^a-zA-Z0-9_-]/g, '_');
  return out.length ? out.slice(0, 128) : 'user';
}

function hasMagicBytes(mime: string, buffer: Buffer): boolean {
  if (mime === 'image/png') {
    // 89 50 4E 47 0D 0A 1A 0A
    return (
      buffer.length >= 8 &&
      buffer.subarray(0, 8).equals(Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]))
    );
  }

  if (mime === 'image/jpeg') {
    // FF D8 FF
    return buffer.length >= 3 && buffer[0] === 0xff && buffer[1] === 0xd8 && buffer[2] === 0xff;
  }

  if (mime === 'image/gif') {
    // "GIF87a" or "GIF89a"
    return (
      buffer.length >= 6 &&
      (buffer.subarray(0, 6).toString('ascii') === 'GIF87a' ||
        buffer.subarray(0, 6).toString('ascii') === 'GIF89a')
    );
  }

  if (mime === 'image/webp') {
    // "RIFF....WEBP"
    return (
      buffer.length >= 12 &&
      buffer.subarray(0, 4).toString('ascii') === 'RIFF' &&
      buffer.subarray(8, 12).toString('ascii') === 'WEBP'
    );
  }

  return false;
}

export const POST = withApiLogging('api.users.avatar', async (request: NextRequest) => {
  const auth = getAuth();
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) {
    throw unauthorized();
  }

  let formData: FormData;
  try {
    formData = await request.formData();
  } catch (err) {
    throw badRequest('Invalid form data', err);
  }

  const file = formData.get('file');
  if (!(file instanceof File)) {
    throw badRequest('file is required');
  }

  if (!ALLOWED_MIME.has(file.type)) {
    throw badRequest('Unsupported file type');
  }

  if (file.size > MAX_BYTES) {
    throw badRequest('File too large (max 2MB)');
  }

  const ext = EXT_BY_MIME[file.type] ?? 'bin';
  const safeUserId = toSafePathSegment(session.user.id);
  const key = `avatars/${safeUserId}/${crypto.randomUUID()}.${ext}`;
  const storage = getStorage();
  const body = Buffer.from(await file.arrayBuffer());

  if (!hasMagicBytes(file.type, body)) {
    throw badRequest('File content does not match declared type');
  }

  const storedKey = await storage.upload(key, body);
  const url = storage.getUrl(storedKey);

  return NextResponse.json({ url }, { status: 201 });
});
