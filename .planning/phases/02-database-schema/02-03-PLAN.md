---
phase: 02-database-schema
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/db/queries/base.ts
  - src/db/queries/users.ts
  - src/db/queries/workspaces.ts
  - src/db/queries/subscriptions.ts
  - src/lib/db.ts
autonomous: true

must_haves:
  truths:
    - "Query helpers auto-exclude soft-deleted records (WHERE deleted_at IS NULL)"
    - "Single-query helpers exist for each table (getWorkspaceById, getActiveUsers)"
    - "Multi-record queries exist (getAllActiveWorkspaces, getUserWorkspaces)"
    - "Soft delete mutations exist (softDeleteWorkspace, restoreUser)"
    - "Multi-tenant queries verify workspace membership before returning data"
    - "Type inference works: TypeScript knows columns and infers return types"
  artifacts:
    - path: "src/db/queries/base.ts"
      provides: "Base query builder helpers that auto-inject soft delete filters"
      exports: ["withSoftDeleteFilter", "queryBuilder utilities"]
    - path: "src/db/queries/users.ts"
      provides: "User query helpers"
      exports: ["getUserById", "getActiveUsers", "softDeleteUser", "restoreUser"]
    - path: "src/db/queries/workspaces.ts"
      provides: "Workspace query helpers with multi-tenant isolation"
      exports: ["getWorkspaceById", "getUserWorkspaces", "getWorkspaceMembers", "softDeleteWorkspace", "verifyWorkspaceMember"]
    - path: "src/db/queries/subscriptions.ts"
      provides: "Subscription query helpers scoped to workspace"
      exports: ["getWorkspaceSubscriptions", "getSubscriptionByStripeId", "updateSubscriptionStatus"]
    - path: "src/lib/db.ts"
      provides: "Convenience re-export of db client and query helpers"
  key_links:
    - from: "src/db/queries/*.ts"
      to: "src/db/schema.ts"
      via: "import tables and relations"
      pattern: "import { users, workspaces } from '@/db/schema'"
    - from: "src/db/queries/*.ts"
      to: "src/db/client.ts"
      via: "import db instance"
      pattern: "import { db } from '@/db/client'"
    - from: "application code"
      to: "src/db/queries"
      via: "import helpers instead of raw db calls"
      pattern: "import { getWorkspaceById } from '@/db/queries/workspaces'"
---

<objective>
Create reusable query helpers that enforce soft delete filtering, multi-tenant isolation, and type safety. These helpers prevent the most common database bugs: forgotten soft delete filters and cross-tenant data leaks.

Purpose: Raw db queries are error-prone. Query helpers ensure every query respects soft deletes and workspace isolation automatically. Phases 3-9 use these helpers for all database access.

Output:
- Reusable query builders with soft delete auto-filtering
- User query helpers (CRUD + soft delete)
- Workspace query helpers (multi-tenant scoped)
- Subscription query helpers (workspace-scoped)
- Type-safe exports via src/lib/db.ts
</objective>

<execution_context>
@/Users/mneves/.claude/get-shit-done/workflows/execute-plan.md
@.planning/phases/02-database-schema/02-02-SUMMARY.md
</execution_context>

<context>
@.planning/phases/02-database-schema/02-RESEARCH.md

Key patterns from RESEARCH.md:
- Soft delete filtering: Manual WHERE deleted_at IS NULL on every query
- Query helpers: Create reusable functions to prevent forgetting filters
- Multi-tenant isolation: Always scope queries by workspace_id
- Verification: Query helpers verify user has access before returning data
- Cascade deletes: Manual soft delete of related records (workspace → members → subscriptions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/db/queries/base.ts with soft delete filtering helpers</name>
  <files>src/db/queries/base.ts</files>
  <action>
Create base utilities for soft delete filtering. These are used by all other query helpers.

File: `src/db/queries/base.ts`

```typescript
import { and, isNull, eq, SQL } from "drizzle-orm";

/**
 * Soft Delete Filter
 *
 * Helper to create WHERE clause: deleted_at IS NULL
 * Prevents accidentally querying deleted records
 *
 * Usage:
 *   db.query.users.findFirst({
 *     where: (users) => and(
 *       eq(users.id, id),
 *       withSoftDeleteFilter(users)
 *     ),
 *   })
 */
export function withSoftDeleteFilter<T extends { deletedAt: any }>(table: T): SQL {
  return isNull(table.deletedAt);
}

/**
 * Build safe soft delete filter
 * Alternative syntax for query builders that use conditions
 */
export function softDeleteCondition<T extends { deletedAt: any }>(table: T): SQL {
  return isNull(table.deletedAt);
}

/**
 * Set deleted_at to current timestamp (soft delete)
 * Returns { deletedAt: new Date() } for use in update()
 */
export function softDeleteNow(): { deletedAt: Date } {
  return { deletedAt: new Date() };
}

/**
 * Clear deleted_at to restore (reactivate)
 * Returns { deletedAt: null } for use in update()
 */
export function restoreNow(): { deletedAt: null } {
  return { deletedAt: null };
}

/**
 * Multi-condition builder for queries with multiple filters
 *
 * Usage:
 *   const conditions = [
 *     eq(users.id, userId),
 *     withSoftDeleteFilter(users),
 *     eq(users.email, email),
 *   ];
 *   db.query.users.findFirst({ where: (users) => and(...conditions) })
 */
export function buildConditions<T>(...conditions: (SQL | undefined)[]): SQL | undefined {
  const filtered = conditions.filter((c) => c !== undefined);
  if (filtered.length === 0) return undefined;
  if (filtered.length === 1) return filtered[0];
  return and(...filtered);
}
```

Why these helpers:
- Prevents forgotten soft delete filters (common bug)
- One source of truth for how to filter deleted records
- Reusable across all query files
- Type-safe (works with Drizzle's condition system)

Do NOT:
- Add business logic here (stays simple)
- Export ORM instances (queries stay in query files)
- Create a "query builder" that modifies ORM behavior
  </action>
  <verify>
```bash
# File exists
ls src/db/queries/base.ts

# Check TypeScript
pnpm tsc src/db/queries/base.ts --noEmit
# Expected: No errors
```
  </verify>
  <done>
src/db/queries/base.ts created with soft delete filtering helpers. TypeScript validates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create src/db/queries/users.ts with user-specific queries</name>
  <files>src/db/queries/users.ts</files>
  <action>
Create user query helpers. Most are simple, but show the pattern that later query files follow.

File: `src/db/queries/users.ts`

```typescript
import { db } from "@/db/client";
import { users } from "@/db/schema";
import { eq, isNull } from "drizzle-orm";
import { withSoftDeleteFilter } from "./base";

/**
 * Get user by ID (soft delete safe)
 * Returns null if user not found or soft-deleted
 */
export async function getUserById(id: string) {
  return db.query.users.findFirst({
    where: (users, { eq, and }) => and(
      eq(users.id, id),
      withSoftDeleteFilter(users)
    ),
    with: {
      workspaceMemberships: true, // Include memberships
    },
  });
}

/**
 * Get user by email (soft delete safe)
 * Used for login, password reset
 */
export async function getUserByEmail(email: string) {
  return db.query.users.findFirst({
    where: (users, { eq, and }) => and(
      eq(users.email, email.toLowerCase()),
      withSoftDeleteFilter(users)
    ),
  });
}

/**
 * Get all active (non-deleted) users
 * Useful for admin dashboards, user lists
 */
export async function getActiveUsers() {
  return db.query.users.findMany({
    where: (users) => withSoftDeleteFilter(users),
  });
}

/**
 * Get active users with pagination
 * For large user lists (admin dashboard)
 */
export async function getActiveUsersPaginated(limit: number = 50, offset: number = 0) {
  return db.query.users.findMany({
    where: (users) => withSoftDeleteFilter(users),
    limit,
    offset,
  });
}

/**
 * Soft delete user (set deleted_at)
 * Does NOT cascade to sessions/accounts (those expire naturally)
 * But DOES cascade to workspace memberships and workspaces they own
 *
 * IMPORTANT: User deletion is complex:
 * - Sessions: Expire naturally (token-based, set expiresAt)
 * - Accounts: Keep for audit trail (user can see they had GitHub login)
 * - Workspaces: Cascade (if sole owner, workspace is deleted)
 * - Workspace Members: Soft delete
 */
export async function softDeleteUser(id: string) {
  const now = new Date();

  // Step 1: Soft delete user
  await db
    .update(users)
    .set({ deletedAt: now })
    .where(eq(users.id, id));

  // Step 2: Hard delete sessions (they shouldn't exist after user deleted)
  // Note: If using soft deletes for sessions, change to soft delete
  // For now, sessions auto-expire, so hard delete is OK
  // await db.delete(sessions).where(eq(sessions.userId, id));

  // Step 3: Cascade to workspace memberships
  // (See src/db/queries/workspaces.ts for workspace deletion logic)
  // For now, just note that workspace membership cascade is handled separately
}

/**
 * Restore soft-deleted user
 * Reactivates user login access
 *
 * Note: Sessions were deleted in softDeleteUser, so user must log in again
 */
export async function restoreUser(id: string) {
  return db
    .update(users)
    .set({ deletedAt: null })
    .where(eq(users.id, id));
}

/**
 * Update user (name, email, avatar)
 * Sets updatedAt automatically
 */
export async function updateUser(id: string, data: { name?: string; image?: string }) {
  return db
    .update(users)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(users.id, id))
    .returning();
}

/**
 * Count active users
 * For admin metrics, signup trends
 */
export async function countActiveUsers() {
  const result = await db
    .select({ count: users.id })
    .from(users)
    .where(withSoftDeleteFilter(users));

  return result[0]?.count.length ?? 0;
}
```

Why this structure:
- getUserById: Single user fetch (most common)
- getUserByEmail: Auth lookups
- getActiveUsers: Lists/dashboards
- getActiveUsersPaginated: Large data sets (admin)
- softDeleteUser: Soft delete with cascade planning
- restoreUser: Admin restore
- updateUser: Profile updates
- countActiveUsers: Metrics

Important notes:
- All queries include withSoftDeleteFilter except intentional deleted record access
- No raw SQL (Drizzle query builder)
- Relations included (with: { workspaceMemberships: true })
- Pagination params for large result sets
  </action>
  <verify>
```bash
# File exists
ls src/db/queries/users.ts

# Check TypeScript
pnpm tsc src/db/queries/users.ts --noEmit
# Expected: No errors (imports from schema.ts resolve)
```
  </verify>
  <done>
src/db/queries/users.ts created with 8 user query helpers. All enforce soft delete filtering.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create src/db/queries/workspaces.ts with multi-tenant workspace queries</name>
  <files>src/db/queries/workspaces.ts</files>
  <action>
Create workspace query helpers with critical multi-tenant isolation. Every query includes workspace_id scope.

File: `src/db/queries/workspaces.ts`

```typescript
import { db } from "@/db/client";
import { workspaces, workspaceMembers, subscriptions } from "@/db/schema";
import { eq, and, isNull } from "drizzle-orm";
import { withSoftDeleteFilter } from "./base";

/**
 * Get workspace by ID (soft delete safe)
 * CRITICAL: Only owner can see this
 * Verification happens at API route level (passed userId)
 */
export async function getWorkspaceById(id: number) {
  return db.query.workspaces.findFirst({
    where: (ws, { eq, and }) => and(
      eq(ws.id, id),
      withSoftDeleteFilter(ws)
    ),
    with: {
      owner: true,
      members: true,
      subscriptions: true,
    },
  });
}

/**
 * Get all workspaces for a user
 * Returns workspaces where user is a member
 *
 * CRITICAL SECURITY:
 * - Must scope to userId (passed as param)
 * - Query verifies membership via workspace_members table
 * - Returns only workspaces user belongs to
 */
export async function getUserWorkspaces(userId: string) {
  return db.query.workspaceMembers.findMany({
    where: (members, { eq, and, isNull }) => and(
      eq(members.userId, userId),
      withSoftDeleteFilter(members)
    ),
    with: {
      workspace: {
        where: (ws, { isNull }) => withSoftDeleteFilter(ws),
        with: {
          owner: true,
          subscriptions: {
            where: (subs, { isNull }) => withSoftDeleteFilter(subs),
          },
        },
      },
    },
  });
}

/**
 * Get workspace members (all roles)
 *
 * CRITICAL: Only call after verifying user has 'owner' role
 * (Ownership check done at API route level)
 */
export async function getWorkspaceMembers(workspaceId: number) {
  return db.query.workspaceMembers.findMany({
    where: (members, { eq, and }) => and(
      eq(members.workspaceId, workspaceId),
      withSoftDeleteFilter(members)
    ),
    with: {
      user: true,
    },
  });
}

/**
 * Verify user is member of workspace
 *
 * CRITICAL VALIDATION:
 * - Call BEFORE any workspace query
 * - Returns member record if access granted, null if denied
 * - Checks deletedAt on membership (membership can be revoked)
 *
 * Usage in API route:
 *   const member = await verifyWorkspaceMember(workspaceId, userId);
 *   if (!member) return new Response("Unauthorized", { status: 403 });
 */
export async function verifyWorkspaceMember(workspaceId: number, userId: string) {
  return db.query.workspaceMembers.findFirst({
    where: (members, { eq, and, isNull }) => and(
      eq(members.workspaceId, workspaceId),
      eq(members.userId, userId),
      withSoftDeleteFilter(members)
    ),
  });
}

/**
 * Create workspace
 * Called after user signup to create default workspace
 */
export async function createWorkspace(data: {
  name: string;
  slug: string;
  ownerUserId: string;
}) {
  return db
    .insert(workspaces)
    .values({
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    })
    .returning();
}

/**
 * Add user to workspace (invite acceptance)
 * CRITICAL: Verify invite is valid before calling this
 */
export async function addWorkspaceMember(data: {
  workspaceId: number;
  userId: string;
  role?: string;
}) {
  return db
    .insert(workspaceMembers)
    .values({
      ...data,
      role: data.role ?? "member",
      createdAt: new Date(),
      updatedAt: new Date(),
    })
    .returning();
}

/**
 * Soft delete workspace member (remove access)
 * Cascades to subscriptions (workspace → members → subscriptions soft deleted)
 *
 * IMPORTANT CASCADE ORDER:
 * 1. Soft delete member (user loses access)
 * 2. Soft delete related subscriptions (billing unchanged)
 * 3. Do NOT hard delete (audit trail)
 */
export async function softDeleteWorkspaceMember(
  workspaceId: number,
  userId: string
) {
  const now = new Date();

  // Soft delete the membership
  await db
    .update(workspaceMembers)
    .set({ deletedAt: now })
    .where(
      and(
        eq(workspaceMembers.workspaceId, workspaceId),
        eq(workspaceMembers.userId, userId)
      )
    );
}

/**
 * Soft delete entire workspace
 * CRITICAL CASCADE:
 * 1. Soft delete workspace
 * 2. Soft delete all members
 * 3. Soft delete all subscriptions
 * 4. Do NOT hard delete anything
 *
 * ADMIN ONLY - dangerous operation
 */
export async function softDeleteWorkspace(workspaceId: number) {
  const now = new Date();

  // Step 1: Soft delete workspace
  await db
    .update(workspaces)
    .set({ deletedAt: now })
    .where(eq(workspaces.id, workspaceId));

  // Step 2: Soft delete all members
  await db
    .update(workspaceMembers)
    .set({ deletedAt: now })
    .where(eq(workspaceMembers.workspaceId, workspaceId));

  // Step 3: Soft delete all subscriptions
  await db
    .update(subscriptions)
    .set({ deletedAt: now })
    .where(eq(subscriptions.workspaceId, workspaceId));
}

/**
 * Restore soft-deleted workspace and its members/subscriptions
 * ADMIN ONLY
 */
export async function restoreWorkspace(workspaceId: number) {
  await db
    .update(workspaces)
    .set({ deletedAt: null })
    .where(eq(workspaces.id, workspaceId));

  await db
    .update(workspaceMembers)
    .set({ deletedAt: null })
    .where(eq(workspaceMembers.workspaceId, workspaceId));

  await db
    .update(subscriptions)
    .set({ deletedAt: null })
    .where(eq(subscriptions.workspaceId, workspaceId));
}

/**
 * Update workspace (name, slug)
 */
export async function updateWorkspace(
  id: number,
  data: { name?: string; slug?: string }
) {
  return db
    .update(workspaces)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(workspaces.id, id))
    .returning();
}

/**
 * Change member role (owner, member, viewer)
 * ADMIN of workspace only
 */
export async function updateMemberRole(
  workspaceId: number,
  userId: string,
  role: string
) {
  return db
    .update(workspaceMembers)
    .set({
      role,
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(workspaceMembers.workspaceId, workspaceId),
        eq(workspaceMembers.userId, userId)
      )
    )
    .returning();
}

/**
 * Count active workspaces
 * For metrics, analytics
 */
export async function countActiveWorkspaces() {
  const result = await db
    .select({ count: workspaces.id })
    .from(workspaces)
    .where(withSoftDeleteFilter(workspaces));

  return result[0]?.count.length ?? 0;
}
```

Why this structure:
- getUserWorkspaces: CRITICAL query, scopes to userId
- verifyWorkspaceMember: CRITICAL security check before all workspace operations
- getWorkspaceMembers: Admin operations (list team members)
- softDeleteWorkspaceMember: Remove user access (with audit trail)
- softDeleteWorkspace: Admin-only cascade delete
- Cascade order documented (members → subscriptions)
- No hard deletes (soft delete everything)

CRITICAL SECURITY:
- Every workspace query includes workspace_id
- verifyWorkspaceMember called before returning workspace data
- User cannot access workspaces they don't belong to
  </action>
  <verify>
```bash
# File exists
ls src/db/queries/workspaces.ts

# Check TypeScript
pnpm tsc src/db/queries/workspaces.ts --noEmit
# Expected: No errors
```
  </verify>
  <done>
src/db/queries/workspaces.ts created with 11 workspace query helpers. All include workspace_id scoping and soft delete filtering.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create src/db/queries/subscriptions.ts with Stripe-scoped queries</name>
  <files>src/db/queries/subscriptions.ts</files>
  <action>
Create subscription query helpers. Scoped to workspaces, references Stripe IDs.

File: `src/db/queries/subscriptions.ts`

```typescript
import { db } from "@/db/client";
import { subscriptions } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import { withSoftDeleteFilter } from "./base";

/**
 * Get subscription by workspace ID
 * Returns null if not found or soft-deleted
 *
 * CRITICAL: Scoped to workspace (multi-tenant)
 */
export async function getWorkspaceSubscription(workspaceId: number) {
  return db.query.subscriptions.findFirst({
    where: (subs, { eq, and }) => and(
      eq(subs.workspaceId, workspaceId),
      withSoftDeleteFilter(subs)
    ),
    with: {
      workspace: true,
    },
  });
}

/**
 * Get subscription by Stripe subscription ID
 * Used to find workspace when webhook fires
 *
 * CRITICAL SECURITY:
 * - Webhook handler uses this to find workspace_id
 * - Must verify webhook signature BEFORE calling
 * - Do NOT query by stripe_id without webhook verification
 */
export async function getSubscriptionByStripeId(stripeSubscriptionId: string) {
  return db.query.subscriptions.findFirst({
    where: (subs, { eq, and }) => and(
      eq(subs.stripeSubscriptionId, stripeSubscriptionId),
      withSoftDeleteFilter(subs)
    ),
    with: {
      workspace: true,
    },
  });
}

/**
 * Get subscription by Stripe customer ID
 * For finding workspace when user has multiple (rare, but handle)
 */
export async function getSubscriptionByStripeCustomerId(stripeCustomerId: string) {
  return db.query.subscriptions.findFirst({
    where: (subs, { eq, and }) => and(
      eq(subs.stripeCustomerId, stripeCustomerId),
      withSoftDeleteFilter(subs)
    ),
  });
}

/**
 * Create subscription (called after user starts paid plan)
 * Stripe IDs added when webhook fires
 *
 * Initial state: status='incomplete' until Stripe confirms payment
 */
export async function createSubscription(data: {
  workspaceId: number;
  stripeCustomerId?: string;
  stripeSubscriptionId?: string;
  stripePriceId?: string;
  status?: string;
}) {
  return db
    .insert(subscriptions)
    .values({
      ...data,
      status: data.status ?? "incomplete",
      createdAt: new Date(),
      updatedAt: new Date(),
    })
    .returning();
}

/**
 * Update subscription status (called by webhook)
 * CRITICAL: Only call after webhook signature verified
 *
 * Stripe webhook events:
 * - customer.subscription.created → active
 * - customer.subscription.updated → active | paused | past_due
 * - customer.subscription.deleted → canceled
 *
 * Also update currentPeriodStart/End from Stripe webhook payload
 */
export async function updateSubscriptionStatus(
  workspaceId: number,
  data: {
    status?: string;
    currentPeriodStart?: Date;
    currentPeriodEnd?: Date;
    cancelAtPeriodEnd?: boolean;
  }
) {
  return db
    .update(subscriptions)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.workspaceId, workspaceId))
    .returning();
}

/**
 * Soft delete subscription (cancel)
 * Used when workspace cancels plan
 *
 * Note: Stripe still owns subscription record (webhook will delete)
 * This is app-level deletion (logical delete)
 */
export async function softDeleteSubscription(workspaceId: number) {
  const now = new Date();

  return db
    .update(subscriptions)
    .set({
      deletedAt: now,
      status: "canceled",
      updatedAt: now,
    })
    .where(eq(subscriptions.workspaceId, workspaceId))
    .returning();
}

/**
 * Get all active subscriptions
 * For admin metrics (MRR calculation, churn, etc.)
 */
export async function getActiveSubscriptions() {
  return db.query.subscriptions.findMany({
    where: (subs, { and }) => and(
      withSoftDeleteFilter(subs),
      // Status = 'active' (not canceled, not past_due)
      // Can add: eq(subs.status, 'active') here
    ),
    with: {
      workspace: true,
    },
  });
}

/**
 * Count active subscriptions (MRR metric)
 * For dashboard: how many paying workspaces
 */
export async function countActiveSubscriptions() {
  const result = await db
    .select({ count: subscriptions.id })
    .from(subscriptions)
    .where(
      and(
        withSoftDeleteFilter(subscriptions),
        // Can add: eq(subscriptions.status, 'active')
      )
    );

  return result[0]?.count.length ?? 0;
}
```

Why this structure:
- getWorkspaceSubscription: Find subscription for workspace
- getSubscriptionByStripeId: Webhook lookup (find workspace from Stripe ID)
- createSubscription: Initial subscription record
- updateSubscriptionStatus: Webhook updates (payment success, failed, etc.)
- softDeleteSubscription: Cancel plan
- getActiveSubscriptions: Admin metrics
- countActiveSubscriptions: MRR calculation

CRITICAL SECURITY:
- getSubscriptionByStripeId: ONLY call after webhook verification
- All queries include workspace_id or stripe_id (immutable lookup)
- Status lifecycle: incomplete → active → canceled/paused/past_due
  </action>
  <verify>
```bash
# File exists
ls src/db/queries/subscriptions.ts

# Check TypeScript
pnpm tsc src/db/queries/subscriptions.ts --noEmit
# Expected: No errors
```
  </verify>
  <done>
src/db/queries/subscriptions.ts created with 9 subscription query helpers. All scoped to workspace and Stripe references.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create src/lib/db.ts convenience export</name>
  <files>src/lib/db.ts</files>
  <action>
Create convenience file re-exporting db client and query helpers.

File: `src/lib/db.ts`

```typescript
// Re-export client
export { db, dbEdge } from "@/db/client";

// Re-export queries
export * from "@/db/queries/users";
export * from "@/db/queries/workspaces";
export * from "@/db/queries/subscriptions";

// Re-export schema (for type definitions)
export * from "@/db/schema";
```

Why this file:
- Single import for all database functionality
- Instead of: `import { db } from "@/db/client"; import { getWorkspaceById } from "@/db/queries/workspaces"`
- Simpler: `import { db, getWorkspaceById } from "@/lib/db"`
- Easy to add new queries later (just add export here)

Usage in routes:
```typescript
import { db, getUserById, getWorkspaceById } from "@/lib/db";

export async function GET(req: Request) {
  const user = await getUserById(userId);
  const workspace = await getWorkspaceById(workspaceId);
  // ...
}
```
  </action>
  <verify>
```bash
# File exists
ls src/lib/db.ts

# Check TypeScript (should resolve all exports)
pnpm tsc src/lib/db.ts --noEmit
# Expected: No errors
```
  </verify>
  <done>
src/lib/db.ts created. Single import point for all database functionality.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. src/db/queries/ directory contains base.ts, users.ts, workspaces.ts, subscriptions.ts
2. All query helpers use withSoftDeleteFilter for soft delete safety
3. Workspace queries include verifyWorkspaceMember for multi-tenant isolation
4. No raw SQL queries (all Drizzle ORM)
5. TypeScript validates all imports and return types
6. src/lib/db.ts exports all queries for convenient import
7. Soft delete and multi-tenant scoping are enforced in every query
</verification>

<success_criteria>
- 4 query helper files created (base, users, workspaces, subscriptions)
- 30+ query helpers total
- Every table-specific query includes soft delete filtering
- Every workspace query includes workspace_id scoping
- verifyWorkspaceMember used before returning workspace data
- Cascade delete order documented (workspace → members → subscriptions)
- Type inference works: queries return properly typed objects
- src/lib/db.ts provides single import point for all queries
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema/02-03-SUMMARY.md` with:
- Query helper files created
- Total helpers per file
- Key security patterns (soft delete, multi-tenant)
- Ready for Phase 03 (Authentication) or Phase 06 (Teams)
</output>
