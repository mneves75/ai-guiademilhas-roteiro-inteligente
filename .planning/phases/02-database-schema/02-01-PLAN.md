---
phase: 02-database-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - drizzle.config.ts
  - src/db/client.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Database connection string is configured in environment"
    - "Drizzle ORM is installed and exported from src/db/client"
    - "Both Node.js and Edge runtime clients are available"
  artifacts:
    - path: "drizzle.config.ts"
      provides: "Drizzle migration and schema configuration"
      contains: ["defineConfig", "PostgreSQL dialect", "migrations", "snake_case casing"]
    - path: "src/db/client.ts"
      provides: "Drizzle client instances for Node and Edge runtimes"
      exports: ["db (Node.js)", "db (Edge/serverless)"]
    - path: ".env.example"
      provides: "Documentation of required DATABASE_URL environment variable"
  key_links:
    - from: "drizzle.config.ts"
      to: "src/db/migrations/"
      via: "drizzle-kit generate"
      pattern: "schema: ./src/db/schema.ts"
    - from: "src/db/client.ts"
      to: "drizzle-orm"
      via: "import drizzle from drizzle-orm"
      pattern: "drizzle(client, { schema })"
---

<objective>
Install Drizzle ORM and configure database connection with both Node.js and Edge-compatible clients.

Purpose: Core database layer must exist before schema definition, migrations, or queries can work. Phase 1 established TypeScript + tooling; Phase 2.1 installs the ORM itself.

Output:
- Drizzle ORM dependencies installed
- Configuration file ready for schema
- Client exports for both Node and Edge runtimes
- Environment documentation updated
</objective>

<execution_context>
@/Users/mneves/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mneves/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-database-schema/02-RESEARCH.md

Key patterns from RESEARCH.md:
- Drizzle 0.38+, postgres driver, @neondatabase/serverless
- drizzle.config.ts: snake_case casing, PostgreSQL dialect
- Two client exports: Node.js (postgres) + Edge (neon-serverless)
- Connection pooling via Neon's -pooler suffix in DATABASE_URL
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Drizzle ORM and database drivers</name>
  <files>package.json</files>
  <action>
Install core Drizzle dependencies:
- drizzle-orm (type-safe ORM)
- postgres (Node.js database driver)
- @neondatabase/serverless (Edge runtime driver)
- drizzle-kit (migrations and CLI)
- zod + drizzle-zod (schema validation - optional but recommended)

Commands:
```bash
cd /Users/mneves/dev/nextjs-bootstrapped-shipped
pnpm add drizzle-orm postgres @neondatabase/serverless
pnpm add -D drizzle-kit
pnpm add zod
```

Why these versions:
- drizzle-orm 0.38+: Latest stable with best TypeScript inference
- postgres 8.x: Mature Node.js driver with connection pooling
- @neondatabase/serverless: Official Neon driver for Edge Functions
- drizzle-kit: Auto-generates migrations from TypeScript schema
- zod: Type validation for API schemas (pairs with drizzle-zod)

Do NOT use Prisma (heavier), TypeORM (verbose), or Knex (outdated patterns).
  </action>
  <verify>
```bash
# Verify installations
pnpm list drizzle-orm postgres @neondatabase/serverless drizzle-kit zod
# Expected: All packages appear with 0.38+, 8.x, latest, 0.24+, latest versions
```
  </verify>
  <done>
All four dependencies installed and appear in package.json. No TypeScript errors from imports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create drizzle.config.ts configuration file</name>
  <files>drizzle.config.ts</files>
  <action>
Create Drizzle configuration file at project root. This file tells drizzle-kit where your schema is, where to output migrations, and how to connect to the database.

File: `drizzle.config.ts`

```typescript
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/db/schema.ts",
  out: "./src/db/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
  casing: "snake_case", // Map TypeScript camelCase to DB snake_case
  migrations: {
    prefix: "index", // Migration naming: 0001_create_users.sql
  },
});
```

Why this configuration:
- schema: Points to single source of truth for table definitions
- out: Migrations go to src/db/migrations (git-tracked)
- dialect: PostgreSQL (not MySQL, SQLite)
- casing: TypeScript camelCase (createdAt) â†’ DB snake_case (created_at)
- prefix: Numbered migrations for easy ordering

Important: Do NOT modify TABLE names or FIELD names after migrations are generated. Renaming requires manual migration.
  </action>
  <verify>
```bash
# File exists and is valid TypeScript
cat drizzle.config.ts | head -5
# Expected: import { defineConfig } from "drizzle-kit";

# Check syntax
pnpm tsc drizzle.config.ts --noEmit
# Expected: No TypeScript errors
```
  </verify>
  <done>
drizzle.config.ts exists at project root with correct PostgreSQL dialect and schema path configuration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create src/db/client.ts with Node.js and Edge clients</name>
  <files>src/db/client.ts</files>
  <action>
Create database client file exporting both Node.js and Edge-compatible clients. This is the single import point for all database queries.

File: `src/db/client.ts`

```typescript
import { drizzle } from "drizzle-orm/postgres-js";
import { drizzle as drizzleEdge } from "drizzle-orm/neon-serverless";
import postgres from "postgres";
import { neon } from "@neondatabase/serverless";
import * as schema from "./schema";

/**
 * Node.js runtime client
 * Use for: API routes, Server Actions, cron jobs
 */
export const db = drizzle(
  postgres(process.env.DATABASE_URL!),
  { schema }
);

/**
 * Edge runtime client (Vercel Edge Functions)
 * Use for: Middleware, Edge API routes, instant functions
 */
export const dbEdge = drizzleEdge(
  neon(process.env.DATABASE_URL!),
  { schema }
);

// Type export for API responses
export type Database = typeof db;
```

Why two clients:
- Node.js client: Uses postgres driver (long-lived connections, better for Server Actions)
- Edge client: Uses @neondatabase/serverless (stateless, optimized for Edge Functions)
- Both use same schema, so types are consistent
- Import whichever client is appropriate for your runtime

Schema import will fail until src/db/schema.ts exists (Plan 02-02). This is expected and will be resolved in the next plan.

Important: Do NOT export a singleton db instance that switches runtime based on environment. Keep them separate and import the right one for your use case.
  </action>
  <verify>
```bash
# File exists
ls -la src/db/client.ts

# Check TypeScript (will fail if schema doesn't exist - that's OK for now)
pnpm tsc src/db/client.ts --noEmit 2>&1 | head -5
# Expected: May show "Cannot find module './schema'" - this is OK, will be fixed in Plan 02-02
```
  </verify>
  <done>
src/db/client.ts exists with both Node.js (db) and Edge (dbEdge) exports. TypeScript error about missing schema is expected until Plan 02-02.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update .env.example with DATABASE_URL</name>
  <files>.env.example</files>
  <action>
Add DATABASE_URL template to .env.example so developers know what environment variable is required.

File: `.env.example` (append or create if doesn't exist)

```
# Database (PostgreSQL via Neon)
# Get from: https://console.neon.tech
# Use pooled connection string for serverless: hostname-pooler.neon.tech
DATABASE_URL=postgresql://user:password@hostname-pooler.neon.tech/dbname?sslmode=require
```

Why pooled connection string:
- `-pooler` suffix routes through PgBouncer (connection pooling)
- Essential for serverless where each function creates new connections
- Without pooling: 50 concurrent requests = 50 DB connections (exhaustion)
- With pooling: 50 requests share 5-10 actual connections

Do NOT use:
- Regular hostname without `-pooler` (will exhaust connections under load)
- Supabase postgres driver (legacy, not optimized for Neon/serverless)
- Custom connection pooling (use Neon's managed PgBouncer)

Instructions for developers:
1. Create Neon project at https://console.neon.tech
2. Copy pooled connection string (contains `-pooler`)
3. Paste into `.env.local`
4. Run `pnpm db:push` to initialize schema
  </action>
  <verify>
```bash
# Check file exists
cat .env.example | grep DATABASE_URL
# Expected: DATABASE_URL=postgresql://...

# Verify it's documented
cat .env.example
# Expected: Comment explains pooled connection string requirement
```
  </verify>
  <done>
.env.example contains DATABASE_URL with documentation about pooled connection strings and Neon setup.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All dependencies install without conflicts
2. drizzle.config.ts is valid TypeScript
3. src/db/client.ts exports both db and dbEdge
4. .env.example documents DATABASE_URL requirement
5. No errors when importing drizzle modules (until schema exists in next plan)
</verification>

<success_criteria>
- drizzle-orm, postgres, @neondatabase/serverless, drizzle-kit installed
- drizzle.config.ts configured with PostgreSQL dialect and snake_case casing
- src/db/client.ts exports both Node and Edge clients
- .env.example documented with DATABASE_URL template
- pnpm list shows all packages, no duplicate versions
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema/02-01-SUMMARY.md` with:
- Dependencies installed (versions)
- Configuration files created
- What's ready for next plan (02-02 schema definition)
</output>
