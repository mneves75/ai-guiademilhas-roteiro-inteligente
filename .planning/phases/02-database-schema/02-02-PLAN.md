---
phase: 02-database-schema
plan: 02
type: execute
wave: 1
depends_on: ["02-01"]
files_modified:
  - src/db/schema.ts
  - src/db/migrations/0001_initial_schema.sql
autonomous: true

must_haves:
  truths:
    - "All tables exist in database with correct columns and relationships"
    - "Schema file exports all table definitions and relations"
    - "Type inference works for table rows and insert types"
    - "Better Auth tables are present with correct structure"
    - "Custom tables (workspaces, subscriptions) include workspace_id for multi-tenancy"
    - "All tables have createdAt, updatedAt, deletedAt timestamp columns"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "TypeScript source of truth for all database tables and relations"
      contains: ["users", "sessions", "accounts", "verification", "workspaces", "workspace_members", "subscriptions", "relations"]
      min_lines: 100
    - path: "src/db/migrations/0001_initial_schema.sql"
      provides: "Initial SQL migration to create all tables"
      contains: ["CREATE TABLE", "PRIMARY KEY", "FOREIGN KEY", "timestamp"]
  key_links:
    - from: "src/db/schema.ts"
      to: "src/db/migrations/0001_initial_schema.sql"
      via: "drizzle-kit generate"
      pattern: "pgTable definitions → SQL CREATE TABLE"
    - from: "src/db/schema.ts"
      to: "src/db/client.ts"
      via: "import schema from './schema'"
      pattern: "db = drizzle(client, { schema })"
---

<objective>
Define complete database schema with Better Auth tables, custom app tables (workspaces, subscriptions), and generate initial migration.

Purpose: Schema is the contract between application code and database. All queries, type inference, and migrations derive from this file. Defines the structure that phases 3-9 depend on.

Output:
- src/db/schema.ts with all table definitions
- Better Auth tables (users, sessions, accounts, verification)
- Custom tables: workspaces, workspace_members, subscriptions
- Relations definitions for type safety
- Initial migration file (SQL)
</objective>

<execution_context>
@/Users/mneves/.claude/get-shit-done/workflows/execute-plan.md
@.planning/phases/02-database-schema/02-01-SUMMARY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-database-schema/02-RESEARCH.md

Key patterns from RESEARCH.md:
- Base entity pattern: createdAt, updatedAt, deletedAt (spread across tables)
- Better Auth schema: user, session, account, verification (auto-generated structure)
- Multi-tenant: workspaces + workspace_members for tenant isolation
- Subscriptions: workspace_id (tenant scoped) + stripe references
- Relations: Define separately to avoid circular dependencies
- Casing: TypeScript camelCase → DB snake_case (via drizzle.config.ts)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/db/schema.ts with all table definitions</name>
  <files>src/db/schema.ts</files>
  <action>
Create comprehensive database schema file with Better Auth tables + custom app tables.

File: `src/db/schema.ts`

```typescript
import {
  pgTable,
  text,
  varchar,
  timestamp,
  boolean,
  serial,
  integer,
  index,
  foreignKey,
  uniqueIndex,
  primaryKey,
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";

/**
 * BASE PATTERN: Reusable timestamps object
 * Spread across all tables for consistency
 */
const timestamps = {
  createdAt: timestamp().defaultNow().notNull(),
  updatedAt: timestamp().defaultNow().notNull(),
  deletedAt: timestamp(), // null = active, set = soft deleted
};

// ==================== BETTER AUTH TABLES ====================
// These match Better Auth's expected schema structure
// See: https://www.better-auth.com/docs/concepts/database

/**
 * USERS TABLE
 * Managed by Better Auth (signup, OAuth, password reset)
 *
 * Note: Better Auth uses UUID strings, not auto-increment
 * emailVerified: true only after email verification
 */
export const users = pgTable(
  "users",
  {
    id: varchar(255).primaryKey(),
    name: varchar(255),
    email: varchar(255).notNull().unique(),
    emailVerified: boolean().notNull().default(false),
    image: varchar(255),
    createdAt: timestamp().notNull(),
    updatedAt: timestamp().notNull(),
  },
  (table) => [
    index("idx_users_email").on(table.email),
  ]
);

/**
 * SESSIONS TABLE
 * Browser session tokens (Better Auth handles creation)
 *
 * token: Secure session token
 * expiresAt: Session expiration (auto-deleted after expiry)
 */
export const sessions = pgTable(
  "sessions",
  {
    id: varchar(255).primaryKey(),
    userId: varchar(255).notNull().references(() => users.id, { onDelete: "cascade" }),
    token: varchar(255).notNull().unique(),
    expiresAt: timestamp().notNull(),
    ipAddress: varchar(255),
    userAgent: varchar(255),
    createdAt: timestamp().notNull(),
    updatedAt: timestamp().notNull(),
  },
  (table) => [
    index("idx_sessions_user_id").on(table.userId),
    index("idx_sessions_token").on(table.token),
  ]
);

/**
 * ACCOUNTS TABLE
 * OAuth providers + email/password auth
 *
 * providerId: 'google', 'github', 'credentials'
 * password: Hashed password (only for email/password auth)
 * accessToken/refreshToken: OAuth tokens (null for credentials)
 */
export const accounts = pgTable(
  "accounts",
  {
    id: varchar(255).primaryKey(),
    userId: varchar(255).notNull().references(() => users.id, { onDelete: "cascade" }),
    accountId: varchar(255).notNull(),
    providerId: varchar(255).notNull(),
    accessToken: text(),
    refreshToken: text(),
    accessTokenExpiresAt: timestamp(),
    refreshTokenExpiresAt: timestamp(),
    scope: text(),
    idToken: text(),
    password: varchar(255), // Hashed password for email/password auth
    createdAt: timestamp().notNull(),
    updatedAt: timestamp().notNull(),
  },
  (table) => [
    index("idx_accounts_user_id").on(table.userId),
    uniqueIndex("idx_accounts_provider").on(table.accountId, table.providerId),
  ]
);

/**
 * VERIFICATION TABLE
 * Email verification tokens, password reset tokens
 *
 * identifier: 'email' or user email
 * value: Token value
 * expiresAt: Token expiration (auto-cleanup)
 */
export const verification = pgTable(
  "verification",
  {
    id: varchar(255).primaryKey(),
    identifier: varchar(255).notNull(),
    value: varchar(255).notNull(),
    expiresAt: timestamp().notNull(),
    createdAt: timestamp(),
    updatedAt: timestamp(),
  },
  (table) => [
    index("idx_verification_identifier").on(table.identifier),
  ]
);

// ==================== CUSTOM APP TABLES ====================

/**
 * WORKSPACES TABLE
 * Multi-tenant container. Users belong to one+ workspaces.
 *
 * slug: URL-safe identifier (for routes like /workspace/acme-corp)
 * ownerUserId: User who created the workspace
 *
 * Note: Includes deletedAt for soft deletes (admin can restore)
 */
export const workspaces = pgTable(
  "workspaces",
  {
    id: serial().primaryKey(),
    name: varchar(255).notNull(),
    slug: varchar(255).notNull().unique(),
    ownerUserId: varchar(255).notNull().references(() => users.id, { onDelete: "cascade" }),
    ...timestamps,
  },
  (table) => [
    index("idx_workspaces_owner").on(table.ownerUserId),
    index("idx_workspaces_deleted").on(table.deletedAt),
  ]
);

/**
 * WORKSPACE_MEMBERS TABLE
 * Explicit membership + role (owner, member, viewer)
 *
 * Allows: invite members, revoke access, change roles
 * Soft delete: User removed = deletedAt set (can restore)
 */
export const workspaceMembers = pgTable(
  "workspace_members",
  {
    id: serial().primaryKey(),
    workspaceId: integer().notNull().references(() => workspaces.id, { onDelete: "cascade" }),
    userId: varchar(255).notNull().references(() => users.id, { onDelete: "cascade" }),
    role: varchar(50).notNull().default("member"), // 'owner', 'member', 'viewer'
    ...timestamps,
  },
  (table) => [
    uniqueIndex("idx_workspace_members_unique").on(table.workspaceId, table.userId),
    index("idx_workspace_members_user").on(table.userId),
    index("idx_workspace_members_deleted").on(table.deletedAt),
  ]
);

/**
 * SUBSCRIPTIONS TABLE
 * Stripe billing per workspace
 *
 * stripeCustomerId: Stripe customer linked to workspace
 * stripeSubscriptionId: Stripe subscription object
 * status: 'active', 'canceled', 'past_due', 'paused', 'incomplete'
 * currentPeriodStart/End: Billing cycle dates
 * cancelAtPeriodEnd: Cancel after current period (don't renew)
 *
 * Note: Stripe is source of truth, this table just references it
 */
export const subscriptions = pgTable(
  "subscriptions",
  {
    id: serial().primaryKey(),
    workspaceId: integer().notNull().references(() => workspaces.id, { onDelete: "cascade" }),
    stripeCustomerId: varchar(255).unique(),
    stripeSubscriptionId: varchar(255).unique(),
    stripePriceId: varchar(255),
    status: varchar(50).notNull().default("incomplete"),
    currentPeriodStart: timestamp(),
    currentPeriodEnd: timestamp(),
    cancelAtPeriodEnd: boolean().default(false),
    ...timestamps,
  },
  (table) => [
    index("idx_subscriptions_workspace").on(table.workspaceId),
    index("idx_subscriptions_stripe_customer").on(table.stripeCustomerId),
    index("idx_subscriptions_stripe_subscription").on(table.stripeSubscriptionId),
    index("idx_subscriptions_deleted").on(table.deletedAt),
  ]
);

// ==================== RELATIONS ====================
// Type inference only (no runtime FK enforcement via relations)
// Database FKs are defined in table definitions above

export const userRelations = relations(users, ({ many }) => ({
  workspaces: many(workspaces),
  workspaceMemberships: many(workspaceMembers),
  accounts: many(accounts),
  sessions: many(sessions),
}));

export const workspaceRelations = relations(workspaces, ({ one, many }) => ({
  owner: one(users, { fields: [workspaces.ownerUserId], references: [users.id] }),
  members: many(workspaceMembers),
  subscriptions: many(subscriptions),
}));

export const workspaceMemberRelations = relations(workspaceMembers, ({ one }) => ({
  workspace: one(workspaces, { fields: [workspaceMembers.workspaceId], references: [workspaces.id] }),
  user: one(users, { fields: [workspaceMembers.userId], references: [users.id] }),
}));

export const subscriptionRelations = relations(subscriptions, ({ one }) => ({
  workspace: one(workspaces, { fields: [subscriptions.workspaceId], references: [workspaces.id] }),
}));

// ==================== ZOD SCHEMAS ====================
// For API validation (optional, but recommended)

export const insertWorkspaceSchema = createInsertSchema(workspaces).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  deletedAt: true,
});

export const selectWorkspaceSchema = createSelectSchema(workspaces);

export const insertWorkspaceMemberSchema = createInsertSchema(workspaceMembers).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  deletedAt: true,
});

export const selectWorkspaceMemberSchema = createSelectSchema(workspaceMembers);
```

Why this structure:
- Better Auth tables: Match expected schema exactly (user, session, account, verification)
- Custom tables: workspaces, workspace_members, subscriptions
- Soft deletes: All tables include createdAt, updatedAt, deletedAt
- Multi-tenant: workspaceId on workspace_members, subscriptions
- Indexes: On foreign keys, email, soft-delete filters for query performance
- Relations: Separate from tables to enable type inference
- Zod schemas: For API input validation

Important constraints:
1. Do NOT modify user/session/account/verification field names (Better Auth expects them)
2. Do NOT remove deletedAt columns (required for soft delete pattern)
3. Do NOT add new workspace-scoped tables without workspace_id
4. Indexes on deletedAt enable fast filtering in queries
  </action>
  <verify>
```bash
# File exists and is valid TypeScript
pnpm tsc src/db/schema.ts --noEmit
# Expected: No errors

# Check it has all expected tables
grep -E "export const (users|sessions|accounts|verification|workspaces|workspaceMembers|subscriptions)" src/db/schema.ts
# Expected: All 7 tables found
```
  </verify>
  <done>
src/db/schema.ts exists with all 7 tables (Better Auth + custom), timestamps, relations, and Zod schemas. TypeScript checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate initial migration SQL file</name>
  <files>src/db/migrations/0001_initial_schema.sql</files>
  <action>
Use drizzle-kit to generate SQL migration from TypeScript schema.

Commands:
```bash
# Generate migration (creates SQL file)
pnpm drizzle-kit generate

# Expected output:
# ✓ 0001_initial_schema.sql generated (or similar timestamp)
# ✓ Schema synchronized
```

What this does:
1. Reads src/db/schema.ts
2. Compares to migration history (first time = all tables)
3. Generates SQL CREATE TABLE statements
4. Saves to src/db/migrations/0001_initial_schema.sql
5. Updates .drizzle/migrations.json for tracking

The SQL file will include:
- CREATE TABLE statements for all 7 tables
- PRIMARY KEY constraints
- FOREIGN KEY references
- UNIQUE constraints
- Indexes (idx_* tables)
- DEFAULT values (timestamps, defaults)

Do NOT manually edit generated SQL files. Always regenerate from schema changes.
  </action>
  <verify>
```bash
# Migration file exists
ls -la src/db/migrations/0001_*.sql
# Expected: 0001_initial_schema.sql (or similar) exists

# Check SQL is valid
cat src/db/migrations/0001_*.sql | head -20
# Expected: CREATE TABLE statements

# Verify all tables are in migration
grep -c "CREATE TABLE" src/db/migrations/0001_*.sql
# Expected: 7 (one per table)
```
  </verify>
  <done>
Initial migration generated with CREATE TABLE statements for all 7 tables, indexes, and constraints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Apply migration to local database (development only)</name>
  <files></files>
  <action>
For development, apply migration to local database to sync schema.

Prerequisites:
- DATABASE_URL is set in .env.local (copy from .env.example)
- PostgreSQL database exists and is accessible

Commands:
```bash
# Verify DATABASE_URL is set
echo $DATABASE_URL
# Expected: postgresql://...

# Apply migration
pnpm drizzle-kit push
# Expected: ✓ Database synchronized

# (Optional) View schema visually
pnpm drizzle-kit studio
# Opens UI at http://localhost:5173 (interactive database explorer)
```

Why pnpm drizzle-kit push for development:
- Fast iteration (no migration files created)
- Safe for local development (no production impact)
- Syncs schema instantly

For production (Phase 12 deployment):
- Use pnpm drizzle-kit generate (creates SQL files)
- Commit migrations to git
- Apply via pnpm drizzle-kit migrate (with history)

Note: If DATABASE_URL not set, this step will fail. That's OK — can be done after user sets up Neon account. The schema file itself is ready.
  </action>
  <verify>
```bash
# After pushing, verify tables exist in database
# If using Neon, check in console: https://console.neon.tech
# If using local Postgres:

psql $DATABASE_URL -c "\\dt"
# Expected: List of tables (users, sessions, accounts, verification, workspaces, workspace_members, subscriptions)

# Verify column names and types
psql $DATABASE_URL -c "\\d users"
# Expected: id, name, email, emailVerified, image, createdAt, updatedAt
```
  </verify>
  <done>
Migration applied to development database. All 7 tables exist with correct columns, types, and constraints. Schema is now synchronized with TypeScript definition.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. src/db/schema.ts contains all 7 tables (Better Auth + custom)
2. All tables have id, createdAt, updatedAt, deletedAt (except Better Auth created/updated)
3. workspaces, workspace_members, subscriptions have workspace_id or ownerUserId for multi-tenancy
4. Relations defined separately from tables
5. Initial migration SQL file generated
6. Migration applied to development database (if DATABASE_URL available)
7. Type inference works (no TypeScript errors when importing from schema)
</verification>

<success_criteria>
- src/db/schema.ts has all 7 tables with correct structure
- Timestamps and soft delete (deletedAt) present on all custom tables
- Better Auth tables match expected schema (users, sessions, accounts, verification)
- Multi-tenant design: workspaceId/ownerUserId on relevant tables
- Migration file generated with CREATE TABLE statements
- Database schema in sync with TypeScript schema (or ready to sync after user sets DATABASE_URL)
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-schema/02-02-SUMMARY.md` with:
- Schema structure overview
- All 7 tables defined
- Migration file generated
- Next steps (02-03 query helpers)
</output>
