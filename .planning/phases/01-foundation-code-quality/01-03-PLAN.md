---
phase: 01-foundation-code-quality
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified: [.husky/pre-commit, .lintstagedrc.mjs, package.json, .vercel/project.json, .env.example]
autonomous: true

must_haves:
  truths:
    - "Developer tries to commit code with TypeScript error and git pre-commit hook blocks commit"
    - "Developer tries to commit code with ESLint violations and pre-commit hook blocks commit"
    - "Developer commits valid code and pre-commit hook passes (commit succeeds)"
    - "Developer runs `pnpm install` and Husky hooks are automatically installed"
    - "Vercel GitHub App is connected and creates preview deployments on PR"
    - "Vercel environment variables are documented in .env.example"
  artifacts:
    - path: ".husky/pre-commit"
      provides: "Git pre-commit hook script that runs lint-staged"
      contains: ["lint-staged"]
    - path: ".lintstagedrc.mjs"
      provides: "lint-staged configuration specifying which linters run on which files"
      contains: ["*.{ts,tsx}", "eslint", "prettier"]
    - path: "package.json"
      provides: "Updated with prepare script for Husky auto-installation"
      contains: ["prepare": "husky install"]
    - path: ".vercel/project.json"
      provides: "Vercel project configuration (auto-generated)"
      exports: ["projectId", "orgId"]
    - path: ".env.example"
      provides: "Template for environment variables needed in Vercel"
      contains: ["NEXT_PUBLIC_", "DATABASE_URL"]
  key_links:
    - from: "package.json"
      to: ".husky/"
      via: "prepare script: husky install runs on pnpm install"
      pattern: "prepare.*husky install"
    - from: ".husky/pre-commit"
      to: ".lintstagedrc.mjs"
      via: "hook executes lint-staged which uses this config"
      pattern: "lint-staged"
    - from: ".lintstagedrc.mjs"
      to: "eslint.config.mjs"
      via: "lint-staged runs eslint on staged files"
      pattern: "eslint"
    - from: "Vercel"
      to: ".github/"
      via: "GitHub App integration enables auto-preview deployments on PR"
      pattern: "github"
---

<objective>
Set up Husky pre-commit hooks and lint-staged to prevent bad commits before they reach GitHub. Enable Vercel GitHub App for automatic preview deployments on PR. This completes the local + remote quality enforcement loop.

Purpose: Developers can't accidentally commit broken code. Vercel auto-previews every PR for testing. Team catches issues at two gates: local pre-commit and GitHub CI/CD.

Output: Git hooks installed, lint-staged configured, Vercel connected and deploying previews.
</objective>

<execution_context>
@/Users/mneves/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mneves/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-code-quality/01-RESEARCH.md
@.planning/phases/01-foundation-code-quality/01-01-SUMMARY.md
@.planning/phases/01-foundation-code-quality/01-02-SUMMARY.md

Reference: Husky docs, lint-staged docs, Vercel GitHub integration docs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Husky and create pre-commit hook</name>
  <files>.husky/pre-commit, package.json</files>
  <action>
    Install Husky 9.x via pnpm (if not already installed):
    ```bash
    pnpm install -D husky
    pnpm exec husky install
    ```

    This creates .husky/ directory structure.

    Create .husky/pre-commit file with:
    ```bash
    #!/bin/sh
    . "$(dirname "$0")/_/husky.sh"

    pnpm exec lint-staged
    ```

    Make the script executable:
    ```bash
    chmod +x .husky/pre-commit
    ```

    Update package.json to add prepare script (if not already present):
    ```json
    {
      "scripts": {
        "prepare": "husky install"
      }
    }
    ```

    The prepare script ensures Husky hooks install automatically when developers run `pnpm install` (after cloning).

    Verification that this works:
    - After commit is pushed, clone fresh and run `pnpm install`
    - Check that .husky/ directory exists and pre-commit hook is executable
    - Hook will run automatically on next commit attempt
  </action>
  <verify>
    Check: .husky/pre-commit file exists and is executable (`ls -l .husky/pre-commit` should show -rwxr-xr-x)
    Check: .husky/_/husky.sh exists (created by husky install)
    Check: package.json contains "prepare": "husky install"
    Run locally: `git commit --allow-empty -m "test"` (should trigger pre-commit hook)
  </verify>
  <done>
    Husky installed and pre-commit hook created. Hook will run lint-staged on every commit attempt.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure lint-staged to run linters on staged files</name>
  <files>.lintstagedrc.mjs</files>
  <action>
    Create .lintstagedrc.mjs in project root (JS config for better IDE support):

    ```javascript
    export default {
      // TypeScript + JavaScript files
      '*.{ts,tsx,js,jsx}': ['eslint --fix', 'prettier --write'],

      // JSON files
      '*.json': ['prettier --write'],

      // Markdown files
      '*.md': ['prettier --write'],

      // CSS/SCSS files
      '*.{css,scss}': ['prettier --write'],
    };
    ```

    Explanation:
    - Each pattern maps to an array of commands to run
    - `eslint --fix` auto-fixes ESLint violations (moves them to DONE state)
    - `prettier --write` formats code (moves them to DONE state)
    - Patterns are specific: only run on files that changed (fast)
    - Both commands must succeed for commit to proceed

    Alternative approach (more defensive - check only, don't fix):
    ```javascript
    export default {
      '*.{ts,tsx,js,jsx}': ['eslint --max-warnings=0', 'prettier --check'],
      // ... other patterns
    };
    ```

    Use the --fix version for developer experience (auto-corrects simple issues).
  </action>
  <verify>
    Check: .lintstagedrc.mjs exists and can be parsed as valid JavaScript
    Check: File contains glob patterns for .ts, .tsx, .js, .jsx
    Check: File includes eslint and prettier commands
  </verify>
  <done>
    lint-staged config committed. Will run ESLint and Prettier on staged files before commit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enable Vercel GitHub App for preview deployments</name>
  <files>.vercel/project.json, .env.example</files>
  <action>
    **Step A: Link project to Vercel (CLI)**
    Run:
    ```bash
    pnpm dlx vercel link
    ```

    This creates .vercel/project.json with projectId and orgId. Commit this file.

    Expected output:
    ```
    Set up and deploy "..." with Vercel? (Y/n) Y
    ? Which scope should contain your project? [scope-name]
    ? Link to existing project? (y/N) n
    ? What's your project's name? nextjs-bootstrapped-shipped
    ? In which directory is your code? ./
    ? Want to modify these settings? (y/N) n
    ```

    **Step B: Create .env.example template**
    Create .env.example with required environment variables:
    ```
    # Database (Phase 2)
    DATABASE_URL=

    # Vercel deployment
    VERCEL_PROJECT_ID=
    VERCEL_ORG_ID=

    # Better Auth (Phase 3)
    BETTER_AUTH_SECRET=
    BETTER_AUTH_URL=http://localhost:3000

    # OAuth (Phase 3, optional)
    GITHUB_CLIENT_ID=
    GITHUB_CLIENT_SECRET=
    GOOGLE_CLIENT_ID=
    GOOGLE_CLIENT_SECRET=

    # Stripe (Phase 9)
    NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=
    STRIPE_SECRET_KEY=
    STRIPE_WEBHOOK_SECRET=

    # Email (Phase 7)
    RESEND_API_KEY=

    # Development
    NODE_ENV=development
    NEXT_PUBLIC_APP_URL=http://localhost:3000
    ```

    Add .env.example to git (it's safe - no secrets). Developers copy to .env.local and fill in their values.

    **Step C: Verify GitHub integration**
    - Visit Vercel dashboard (vercel.com)
    - Project should show "Git Integration: Connected"
    - Confirm GitHub App is installed and authorized to access the repo

    **Step D: Configure Vercel environment**
    (Can be done now or later - set production environment variables in Vercel dashboard)
    - Visit Vercel dashboard → Settings → Environment Variables
    - Set production variables (DATABASE_URL, API keys, etc.)
    - Leave preview/development to use .env.local
  </action>
  <verify>
    Check: .vercel/project.json exists and contains projectId and orgId
    Check: .env.example exists and lists environment variables
    Check: Vercel GitHub App is installed in repo (GitHub Settings → Installed GitHub Apps)
    Check: Vercel dashboard shows project is linked
  </verify>
  <done>
    Vercel GitHub App connected. Will automatically create preview deployments on every PR.
    .env.example is documented for future team members to set up locally.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. Test pre-commit hook locally:
   - Create a test file with `const x: any = 5;` (violates no-any rule)
   - Run `git add .`
   - Run `git commit -m "test"` → should be blocked by pre-commit hook
   - Fix the code, run `git add .`, `git commit -m "test"` → should succeed

2. Test Vercel deployment:
   - Push a branch to GitHub
   - Create a PR
   - Vercel should create a preview deployment within 1-2 minutes
   - PR should show "Deploy Preview by Vercel" comment with preview URL

3. Verify hooks persist:
   - Clone the repo fresh in a new directory
   - Run `pnpm install`
   - Check that `ls -l .husky/pre-commit` shows executable
   - Attempt commit with bad code → should be blocked

Success: Full quality enforcement loop is active.
- Local: pre-commit hook blocks bad code
- Remote: GitHub Actions validates in CI
- Deployment: Vercel creates preview for testing
</verification>

<success_criteria>
1. .husky/pre-commit hook exists and is executable
2. package.json contains "prepare": "husky install"
3. .lintstagedrc.mjs exists and configures ESLint + Prettier on staged files
4. .vercel/project.json exists with projectId and orgId
5. Vercel GitHub App is connected (visible in GitHub repo settings)
6. .env.example exists and documents required environment variables
7. Pre-commit hook blocks commits with TypeScript errors or ESLint violations
8. Vercel creates preview deployments on PR (tested manually)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-code-quality/01-03-SUMMARY.md` with:
- Frontmatter: status=complete, artifacts_created=[.husky/, .lintstagedrc.mjs, .vercel/project.json, .env.example], git_hooks_enabled=true, vercel_connected=true
- Summary of Husky + lint-staged + Vercel setup
- Note that all QUAL-* and CICD-* requirements are now covered
- Ready for final verification (Plan 04)
</output>
