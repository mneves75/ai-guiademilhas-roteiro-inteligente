---
phase: 03-authentication-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/auth/request-password-reset/route.ts
  - app/api/auth/reset-password/route.ts
  - app/api/auth/sign-in/magic-link/route.ts
  - src/lib/auth.ts
  - app/api/e2e/auth/bootstrap/route.ts
autonomous: true
requirements: [AUTH-05, AUTH-06]

must_haves:
  truths:
    - "POST /api/auth/request-password-reset sends password reset email via Supabase"
    - "POST /api/auth/reset-password updates user password via Supabase"
    - "POST /api/auth/sign-in/magic-link sends OTP magic link email via Supabase"
    - "E2E auth bypass is blocked when NODE_ENV=production"
  artifacts:
    - path: "app/api/auth/request-password-reset/route.ts"
      provides: "Password reset request endpoint"
      exports: ["POST"]
    - path: "app/api/auth/reset-password/route.ts"
      provides: "Password reset execution endpoint"
      exports: ["POST"]
    - path: "app/api/auth/sign-in/magic-link/route.ts"
      provides: "Magic link OTP endpoint"
      exports: ["POST"]
  key_links:
    - from: "app/(auth)/forgot-password/forgot-password-form.tsx"
      to: "app/api/auth/request-password-reset/route.ts"
      via: "fetch POST /api/auth/request-password-reset"
      pattern: "fetch.*request-password-reset"
    - from: "app/(auth)/reset-password/reset-password-form.tsx"
      to: "app/api/auth/reset-password/route.ts"
      via: "fetch POST /api/auth/reset-password"
      pattern: "fetch.*reset-password"
    - from: "app/(auth)/login/login-form.tsx"
      to: "app/api/auth/sign-in/magic-link/route.ts"
      via: "fetch POST /api/auth/sign-in/magic-link"
      pattern: "fetch.*magic-link"
---

<objective>
Create the 3 missing API routes that UI forms already reference, completing AUTH-05 (password reset) and AUTH-06 (magic link). Also harden the E2E auth bypass with a production guard (SEC-1).

Purpose: These routes are the only functional gaps in the auth system. Without them, forgot-password, reset-password, and magic-link buttons return 404.
Output: 3 new route files + 2 hardened files.
</objective>

<execution_context>
@/Users/mneves/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mneves/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-authentication-core/03-RESEARCH.md

@app/(auth)/forgot-password/forgot-password-form.tsx
@app/(auth)/reset-password/reset-password-form.tsx
@app/(auth)/login/login-form.tsx
@src/lib/supabase/server.ts
@src/lib/auth.ts
@app/api/e2e/auth/bootstrap/route.ts
@app/api/auth/callback/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create password reset API routes (AUTH-05)</name>
  <files>
    app/api/auth/request-password-reset/route.ts
    app/api/auth/reset-password/route.ts
  </files>
  <action>
Create two API route files that match what the existing UI forms expect.

**Route 1: `app/api/auth/request-password-reset/route.ts`**

The `forgot-password-form.tsx` sends:
```json
POST /api/auth/request-password-reset
{ "email": "user@example.com", "redirectTo": "http://localhost:3000/reset-password" }
```

Implementation:
- Import `createSupabaseServerClient` from `@/lib/supabase/server`
- Parse JSON body, extract `email` (string) and `redirectTo` (string)
- Validate `email` is present and is a valid email format
- Call `supabase.auth.resetPasswordForEmail(email, { redirectTo })`
- On success: return `NextResponse.json({ ok: true })` -- ALWAYS return success even if email not found (prevent user enumeration)
- On error: log the error server-side but still return 200 with `{ ok: true }` to prevent enumeration. Only return 400 for validation errors (missing/invalid email).
- Import `NextResponse` from `next/server`

**Route 2: `app/api/auth/reset-password/route.ts`**

The `reset-password-form.tsx` sends:
```json
POST /api/auth/reset-password
{ "newPassword": "...", "token": "..." }
```

IMPORTANT: Supabase password reset flow works differently from traditional token-based reset. When the user clicks the reset link in their email, Supabase redirects to the app's reset-password page with a code in the URL fragment or query. The `@supabase/ssr` client automatically exchanges this for a session. By the time the user submits the new password form, they have an active Supabase session.

Implementation:
- Import `createSupabaseServerClient` from `@/lib/supabase/server`
- Parse JSON body, extract `newPassword` (string)
- Validate `newPassword` is present and >= 8 characters
- Call `supabase.auth.updateUser({ password: newPassword })`
- This works because the user already has a session from clicking the reset link
- On success: return `NextResponse.json({ ok: true })`
- On error: return `NextResponse.json({ error: error.message }, { status: 400 })`
- Handle edge case: if no session exists (user navigated directly without reset link), `updateUser` will fail -- return 401

Both routes must:
- Use `import { NextResponse } from 'next/server'`
- Use `import { createSupabaseServerClient } from '@/lib/supabase/server'`
- Include proper error handling with try/catch
- NOT import or use rate limiting (proxy.ts already rate-limits all POST to `/api/auth`)
  </action>
  <verify>
Run `pnpm type-check` to confirm both routes compile. Verify files exist at:
- `app/api/auth/request-password-reset/route.ts`
- `app/api/auth/reset-password/route.ts`
  </verify>
  <done>Both password reset routes exist, type-check clean, and match the request format expected by forgot-password-form.tsx and reset-password-form.tsx.</done>
</task>

<task type="auto">
  <name>Task 2: Create magic link API route (AUTH-06) and harden E2E bypass (SEC-1)</name>
  <files>
    app/api/auth/sign-in/magic-link/route.ts
    src/lib/auth.ts
    app/api/e2e/auth/bootstrap/route.ts
  </files>
  <action>
**Route: `app/api/auth/sign-in/magic-link/route.ts`**

The `login-form.tsx` sends:
```json
POST /api/auth/sign-in/magic-link
{ "email": "user@example.com", "callbackURL": "/dashboard" }
```

Implementation:
- Import `createSupabaseServerClient` from `@/lib/supabase/server`
- Import `NextResponse` from `next/server`
- Parse JSON body, extract `email` (string) and `callbackURL` (string, optional)
- Validate `email` is present and is a valid email format
- Build `emailRedirectTo`: if `callbackURL` is provided, construct `${origin}/api/auth/callback?next=${encodeURIComponent(callbackURL)}` where `origin` comes from `process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3000'`
- Call `supabase.auth.signInWithOtp({ email, options: { emailRedirectTo } })`
- On success: return `NextResponse.json({ ok: true })` -- ALWAYS return success to prevent user enumeration
- On error: log server-side, return 200 with `{ ok: true }` (same enumeration protection as password reset)
- Only return 400 for validation errors (missing/invalid email)

**SEC-1 Fix: Harden E2E auth bypass**

In `src/lib/auth.ts`, the `getPlaywrightE2ESession()` function checks `process.env.PLAYWRIGHT_E2E !== '1'` but does NOT check `NODE_ENV`. Add a production guard:

```typescript
async function getPlaywrightE2ESession(): Promise<Session | null> {
  if (process.env.NODE_ENV === 'production') return null;  // <-- ADD THIS LINE
  if (process.env.PLAYWRIGHT_E2E !== '1') return null;
  // ... rest unchanged
}
```

In `app/api/e2e/auth/bootstrap/route.ts`, the handler checks `PLAYWRIGHT_E2E !== '1'` but not `NODE_ENV`. Add production guard:

```typescript
export async function POST(request: NextRequest) {
  if (process.env.NODE_ENV === 'production') {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }
  if (process.env.PLAYWRIGHT_E2E !== '1') {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }
  // ... rest unchanged
}
```

Also check `proxy.ts` -- the `hasE2EAuthCookie()` function already gates on `PLAYWRIGHT_E2E !== '1'`, but add `NODE_ENV` guard there too for defense-in-depth. However, since proxy.ts is a larger file with more risk of regression, the production guard in auth.ts and bootstrap route is sufficient (the proxy only checks cookie existence, the authoritative check is in auth.ts getSession).
  </action>
  <verify>
Run `pnpm type-check` to confirm magic link route compiles. Verify files:
- `app/api/auth/sign-in/magic-link/route.ts` exists
- `src/lib/auth.ts` contains `NODE_ENV === 'production'` guard
- `app/api/e2e/auth/bootstrap/route.ts` contains `NODE_ENV === 'production'` guard
  </verify>
  <done>Magic link route exists and type-checks clean. E2E bypass is hardened with NODE_ENV production guard in both auth.ts and bootstrap route.</done>
</task>

</tasks>

<verification>
- `pnpm type-check` passes with 0 errors
- `pnpm lint` passes
- 3 new route files exist and export POST handlers
- forgot-password-form.tsx, reset-password-form.tsx, login-form.tsx fetch targets now resolve to real routes
- SEC-1: `getPlaywrightE2ESession()` returns null when `NODE_ENV=production`
- SEC-1: E2E bootstrap route returns 404 when `NODE_ENV=production`
</verification>

<success_criteria>
AUTH-05 (password reset via email) is complete: request-password-reset calls `resetPasswordForEmail`, reset-password calls `updateUser({ password })`. AUTH-06 (magic link) is complete: sign-in/magic-link calls `signInWithOtp`. SEC-1 is resolved: E2E bypass blocked in production.
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication-core/03-02-SUMMARY.md`
</output>
